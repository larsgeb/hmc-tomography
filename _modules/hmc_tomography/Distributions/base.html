

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hmc_tomography.Distributions.base &mdash; HMC Tom 0.2.2-17-g82b23b2-dirty documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> HMC Tom
          

          
            
            <img src="../../../_static/hmctom.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2.2-17-g82b23b2-dirty
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">HMC Tomography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../setup.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples and tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Alphabetic index</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">HMC Tom</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>hmc_tomography.Distributions.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hmc_tomography.Distributions.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span> <span class="k">as</span> <span class="nn">_warnings</span>

<span class="c1"># from abc import ABCMeta as _ABCMeta</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span> <span class="k">as</span> <span class="n">_abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">_List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span> <span class="k">as</span> <span class="n">_Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_numpy</span>

<span class="kn">from</span> <span class="nn">hmc_tomography.Helpers</span> <span class="kn">import</span> <span class="n">RandomMatrices</span> <span class="k">as</span> <span class="n">_RandomMatrices</span>
<span class="kn">from</span> <span class="nn">hmc_tomography.Helpers.BetterABC</span> <span class="kn">import</span> <span class="n">abstractattribute</span> <span class="k">as</span> <span class="n">_abstractattribute</span>
<span class="kn">from</span> <span class="nn">hmc_tomography.Helpers.BetterABC</span> <span class="kn">import</span> <span class="n">ABCMeta</span> <span class="k">as</span> <span class="n">_ABCMeta</span>
<span class="kn">from</span> <span class="nn">hmc_tomography.Helpers</span> <span class="kn">import</span> <span class="n">CustomExceptions</span> <span class="k">as</span> <span class="n">_CustomExceptions</span>


<div class="viewcode-block" id="_AbstractDistribution"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution">[docs]</a><span class="k">class</span> <span class="nc">_AbstractDistribution</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for distributions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;abstract distribution&quot;</span>
    <span class="sd">&quot;&quot;&quot;Name of the distribution.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="_AbstractDistribution.dimensions"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.dimensions">[docs]</a>    <span class="nd">@_abstractattribute</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions of the model space.</span>

<span class="sd">        This is an abstract parameter. If it is not defined either in your class</span>
<span class="sd">        directly or in its constructor (the __init__ function) then attempting to use</span>
<span class="sd">        the class will raise a NotImplementedError.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Lower bounds for every parameter. If initialized to None, no bounds are used.&quot;&quot;&quot;</span>

    <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Upper bounds for every parameter. If initialized to None, no bounds are used.&quot;&quot;&quot;</span>

    <span class="n">normalized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;Boolean describing if the distribution is normalized, i.e. if we can use it in</span>
<span class="sd">    mixtures of distributions.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="_AbstractDistribution.misfit"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.misfit">[docs]</a>    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes the misfit of the distribution at the given coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the coordinates :math:`\\mathbf{m}`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        misfit : float</span>
<span class="sd">            The distribution misfit :math:`\\chi`.</span>


<span class="sd">        The distribution misfit is related to the distribution probability density as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\chi_\\text{distribution} (\\mathbf{m}) = -\\log p(\\mathbf{m}).</span>


<span class="sd">        This method is called many times in an HMC appraisal. It is therefore</span>
<span class="sd">        beneficial to optimize the implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">AbstractMethodError</span><span class="p">(</span>
            <span class="s2">&quot;You tried accessing an abstract method directly through a class. This is &quot;</span>
            <span class="s2">&quot;not allowed. Create an instance of this object and call this method from &quot;</span>
            <span class="s2">&quot;the instance.&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="_AbstractDistribution.gradient"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.gradient">[docs]</a>    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes the misfit gradient of the distribution at the given coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the coordinates :math:`\\mathbf{m}`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gradient : numpy.ndarray</span>
<span class="sd">            The distribution misfit gradient :math:`\\nabla_\\mathbf{m}\\chi`.</span>


<span class="sd">        The distribution misfit gradient is related to the distribution probability</span>
<span class="sd">        density as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\nabla_\\mathbf{m} \\chi_\\text{distribution} (\\mathbf{m}) = -</span>
<span class="sd">            \\nabla_\\mathbf{m} \\log p(\\mathbf{m}).</span>


<span class="sd">        This method is called many times in an HMC appraisal. It is therefore</span>
<span class="sd">        beneficial to optimize the implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">AbstractMethodError</span><span class="p">(</span>
            <span class="s2">&quot;You tried accessing an abstract method directly through a class. This is &quot;</span>
            <span class="s2">&quot;not allowed. Create an instance of this object and call this method from &quot;</span>
            <span class="s2">&quot;the instance.&quot;</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;This distribution is not normalizable.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="_AbstractDistribution.generate"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to draw samples from the distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sample : numpy.ndarray</span>
<span class="sd">            A numpy array shaped as (dimensions, 1) containing a sample of the</span>
<span class="sd">            distribution.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the distribution does not allow generation of samples.</span>


<span class="sd">        This method is mostly a convenience class. The algorithm itself does not</span>
<span class="sd">        require the implementation. Therefore an implementation as such will suffice::</span>

<span class="sd">            def generate(self) -&gt; _numpy.ndarray:</span>
<span class="sd">                raise NotImplementedError(&quot;This function is not implemented.&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">AbstractMethodError</span><span class="p">(</span>
            <span class="s2">&quot;You tried accessing an abstract method directly through a class. This is &quot;</span>
            <span class="s2">&quot;not allowed. Create an instance of this object and call this method from &quot;</span>
            <span class="s2">&quot;the instance.&quot;</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_AbstractDistribution&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;You tried creating a default distribution. Although you have used this &quot;</span>
            <span class="s2">&quot;method correctly, it wasn&#39;t implemented in the derived class. Create the &quot;</span>
            <span class="s2">&quot;static method `create_default(dimensions)` which returns a distribution, &quot;</span>
            <span class="s2">&quot;and try calling this method again.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="_AbstractDistribution.corrector"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.corrector">[docs]</a>    <span class="k">def</span> <span class="nf">corrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">momentum</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to correct an HMC particle, which is called after every time</span>
<span class="sd">        integration step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the coordinates :math:`\\mathbf{m}` upon which to operate by</span>
<span class="sd">            reference.</span>
<span class="sd">        momentum : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the momenta :math:`\\mathbf{p}` upon which to operate by</span>
<span class="sd">            reference.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Lower bound correction</span>
            <span class="n">too_low</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Upper bound correction</span>
            <span class="n">too_high</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span></div>

<div class="viewcode-block" id="_AbstractDistribution.update_bounds"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.update_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">update_bounds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to update bounds of a distribution distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        lower_bounds : numpy.ndarray or `None`</span>
<span class="sd">            Either an array shaped as (dimensions, 1) with floats for the lower bounds,</span>
<span class="sd">            or `None` for no bounds. If some dimensions should be bounded, while others</span>
<span class="sd">            should not, use ``-numpy.inf`` within the vector as needed.</span>
<span class="sd">        upper_bounds : numpy.ndarray or `None`</span>
<span class="sd">            Either an array shaped as (dimensions, 1) with floats for the upper bounds,</span>
<span class="sd">            or `None` for no bounds. If some dimensions should be bounded, while others</span>
<span class="sd">            should not, use ``numpy.inf`` within the vector as needed.</span>


<span class="sd">        This method updates the bounds of a distribution. Note that invocating it,</span>
<span class="sd">        requires both bounds to be passed. If only one is to be updated, simply pass</span>
<span class="sd">        the current object of the other bound::</span>

<span class="sd">            distribution.update_bounds(numpy.zeros((4, 1)), distribution.upper_bounds)</span>


<span class="sd">        If both vectors are passed, ensure that all upper bounds are above the</span>
<span class="sd">        corresponding lower bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">old_limits</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">)</span>

        <span class="c1"># Set the bounds ---------------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">upper_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span>

        <span class="c1"># Check the types --------------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># Lower bound is wrong</span>

            <span class="c1"># Reset bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">old_limits</span>

            <span class="c1"># Raise error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lower bounds object not understood.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="c1"># Upper bound is wrong</span>

            <span class="c1"># Reset bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">old_limits</span>

            <span class="c1"># Raise error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Upper bounds object not understood.&quot;</span><span class="p">)</span>

        <span class="c1"># Check for both arrays; if they are not None, if the dimension is correct. ----</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Reset bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">old_limits</span>

            <span class="c1"># Raise error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bounds vectors are of incorrect size.&quot;</span><span class="p">)</span>

        <span class="c1"># Check that all upper bounds are (finitely) above lower bounds ----------------</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Reset bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">old_limits</span>

            <span class="c1"># Raise error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bounds vectors are incompatible.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="_AbstractDistribution.misfit_bounds"><a class="viewcode-back" href="../../../api/distributions/_AbstractDistribution.html#hmc_tomography.Distributions._AbstractDistribution.misfit_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">misfit_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the misfit associated with the truncated part of the distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">coordinates</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">coordinates</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="mf">0.0</span></div></div>


<span class="k">class</span> <span class="nc">StandardNormal1D</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Standard normal distribution in 1 dimension.&quot;&quot;&quot;</span>

    <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">std</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Standard normal distribution in 1 dimension.&quot;</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">Assertions</span><span class="o">.</span><span class="n">assert_shape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">Assertions</span><span class="o">.</span><span class="n">assert_shape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">m</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;StandardNormal1D&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">StandardNormal1D</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">InvalidCaseError</span><span class="p">()</span>


<div class="viewcode-block" id="Normal"><a class="viewcode-back" href="../../../api/distributions/Normal.html#hmc_tomography.Distributions.Normal">[docs]</a><span class="k">class</span> <span class="nc">Normal</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normal distribution in model space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : int</span>
<span class="sd">        Dimension of the distribution.</span>
<span class="sd">    means : numpy.ndarray</span>
<span class="sd">        Numpy array shaped as (dimensions, 1) containing the means of the distribution.</span>
<span class="sd">    covariance : numpy.ndarray</span>
<span class="sd">        Numpy array shaped as either as (dimensions, dimensions) or (dimensions, 1).</span>
<span class="sd">        This array represents either the full covariance matrix for a multivariate</span>
<span class="sd">        Gaussian, or an column vector with variances for `dimensions` separate</span>
<span class="sd">        uncorrelated Gaussians.</span>
<span class="sd">    lower_bounds: numpy.ndarray</span>
<span class="sd">        Numpy array of shape (dimensions, 1) that contains the lower limits of each</span>
<span class="sd">        parameter.</span>
<span class="sd">    upper_bounds: numpy.ndarray</span>
<span class="sd">        Numpy array of shape (dimensions, 1) that contains the upper limits of each</span>
<span class="sd">        parameter.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">means</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">covariance</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">inverse_covariance</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Gaussian (normal) distribution&quot;</span>

        <span class="c1"># Automatically get dimensionality from means</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">size</span>
        <span class="sd">&quot;&quot;&quot;Amount of dimensions on which the distribution is defined, should agree with</span>
<span class="sd">        means and covariance, and optionally coordinate_transformation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Indicator whether or not the covariance matrix is diagonal, i.e. if the</span>
<span class="sd">        distribution is uncorrelated.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Means in model space&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Covariance matrix in model space&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Inverse covariance matrix&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="sd">&quot;&quot;&quot;Covariance matrix determinant and dimensionality factored in single</span>
<span class="sd">        likelihood term. Uncomputed if normalized() is never called.&quot;&quot;&quot;</span>

        <span class="c1"># Parse means</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Seems that you only passed a float/int as the means vector. &quot;</span>
                <span class="s2">&quot;It will be used as a single mean for all dimensions.&quot;</span><span class="p">,</span>
                <span class="ne">Warning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">means</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">means</span>
        <span class="k">elif</span> <span class="n">means</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incorrect size of means vector.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">means</span>

        <span class="c1"># Parse covariance</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float64</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float32</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
        <span class="p">):</span>
            <span class="n">covariance</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Seems that you only passed a float/int as the covariance matrix. &quot;</span>
                <span class="s2">&quot;It will be used as a single covariance for all dimensions.&quot;</span><span class="p">,</span>
                <span class="ne">Warning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">covariance</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># Supplied a full covariance matrix, could be either NumPy or SciPy</span>
            <span class="c1"># matrix.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">covariance</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Supplied a diagonal of a covariance matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Seems that you only passed a vector as the covariance matrix. &quot;</span>
                <span class="s2">&quot;It will be used as the covariance diagonal.&quot;</span><span class="p">,</span>
                <span class="ne">Warning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Covariance matrix shape not understood.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">covariance</span>

        <span class="c1"># Precomputing inverses to speed up misfit and gradient computation ------------</span>
        <span class="k">if</span> <span class="n">inverse_covariance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># There are many ways in which one could optimize the computation of a</span>
            <span class="c1"># specific PD-matrix inverse. Let the user compute and provide it if wanted.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span> <span class="o">=</span> <span class="n">inverse_covariance</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">:</span>
            <span class="c1"># If the user does not provide one, at least check if the covariance matrix</span>
            <span class="c1"># is diagonal, which makes computation of the inverse scale much better.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Else, brute force calculation of the inverse using numpy.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>

        <span class="c1"># Process optional bounds ------------------------------------------------------</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_bounds</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">)</span>

<div class="viewcode-block" id="Normal.misfit"><a class="viewcode-back" href="../../../api/distributions/Normal.html#hmc_tomography.Distributions.Normal.misfit">[docs]</a>    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the misfit of a Normal distribution distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
                <span class="o">+</span> <span class="mf">0.5</span>
                <span class="o">*</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<div class="viewcode-block" id="Normal.gradient"><a class="viewcode-back" href="../../../api/distributions/Normal.html#hmc_tomography.Distributions.Normal.gradient">[docs]</a>                    <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
                <span class="o">+</span> <span class="mf">0.5</span>
                <span class="o">*</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span>
                    <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the gradient of a Normal distribution distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span>
            <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">inverse_covariance</span> <span class="o">@</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">coordinates</span>
            <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float64</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float32</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
        <span class="p">):</span>
            <span class="n">determinant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">determinant</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">determinant</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Covariance matrix shape not understood.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">determinant</span><span class="p">))</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">*</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Normal&quot;</span><span class="p">:</span>

        <span class="c1"># Create random means</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create a PD matrix with some extra definiteness by adding the identity</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">_RandomMatrices</span><span class="o">.</span><span class="n">random_correlation_matrix</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="c1"># Standard deviations between 1 and 2</span>
        <span class="n">standard_deviations</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">covariance</span> <span class="o">=</span> <span class="n">standard_deviations</span> <span class="o">@</span> <span class="n">correlation</span> <span class="o">@</span> <span class="n">standard_deviations</span>

        <span class="k">return</span> <span class="n">Normal</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Laplace"><a class="viewcode-back" href="../../../api/distributions/Laplace.html#hmc_tomography.Distributions.Laplace">[docs]</a><span class="k">class</span> <span class="nc">Laplace</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Laplace distribution in model space.</span>

<span class="sd">    Least absolute deviations, Laplace distribution, LASSO, L1</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">means</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">dispersions</span><span class="p">:</span> <span class="n">_Union</span><span class="p">[</span><span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Automatically get dimensionality from means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">means</span>
        <span class="sd">&quot;&quot;&quot;A float or numpy.ndarray of shape (dimensions, 1) of floats describing the</span>
<span class="sd">        mean of the uncorrelated multivariate Laplace distribution.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span> <span class="o">=</span> <span class="n">dispersions</span>
        <span class="sd">&quot;&quot;&quot;A positive float or numpy.ndarray of shape (dimensions, 1) of positive floats</span>
<span class="sd">        describing the dispersion of the uncorrelated multivariate Laplace</span>
<span class="sd">        distribution.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inverse_dispersions</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dispersions</span>
        <span class="sd">&quot;&quot;&quot;A positive float or numpy.ndarray of shape (dimensions, 1) of positive floats</span>
<span class="sd">        describing the inverse dispersion of the uncorrelated multivariate Laplace</span>
<span class="sd">        distribution. Used to accelerate computations at the cost of memory usage.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_bounds</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">)</span>

<div class="viewcode-block" id="Laplace.misfit"><a class="viewcode-back" href="../../../api/distributions/Laplace.html#hmc_tomography.Distributions.Laplace.misfit">[docs]</a>    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the misfit of a L1 distribution distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">_numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coordinates</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_dispersions</span>
            <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Laplace.gradient"><a class="viewcode-back" href="../../../api/distributions/Laplace.html#hmc_tomography.Distributions.Laplace.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the gradient of a L1 distribution distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The derivative of the function |x| is simply 1 or -1, depending on the sign</span>
        <span class="c1"># of x, subsequently scaled by the dispersion.</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">coordinates</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_dispersions</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float64</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">)</span> <span class="o">==</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">float32</span>
            <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalization_constant</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Covariance matrix shape not understood.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laplace&quot;</span><span class="p">:</span>

        <span class="c1"># Create random means</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create a PD matrix with some extra definiteness by adding the identity</span>
        <span class="n">dispersions</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Laplace</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">dispersions</span><span class="p">)</span></div>


<div class="viewcode-block" id="Uniform"><a class="viewcode-back" href="../../../api/distributions/Uniform.html#hmc_tomography.Distributions.Uniform">[docs]</a><span class="k">class</span> <span class="nc">Uniform</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uniform bounded or unbouded distribution in model space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lower_bounds: numpy.ndarray or None</span>
<span class="sd">        Numpy array of shape (dimensions, 1) that contains the lower limits of each</span>
<span class="sd">        parameter.</span>
<span class="sd">    upper_bounds: numpy.ndarray or None</span>
<span class="sd">        Numpy array of shape (dimensions, 1) that contains the upper limits of each</span>
<span class="sd">        parameter.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;uniform distribution&quot;</span>

        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span>
        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="p">(</span><span class="n">lower_bounds</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">)</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">upper_bounds</span><span class="p">,</span> <span class="p">(</span><span class="n">upper_bounds</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Automatically get dimensionality from bounds</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_bounds</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">)</span>

<div class="viewcode-block" id="Uniform.misfit"><a class="viewcode-back" href="../../../api/distributions/Uniform.html#hmc_tomography.Distributions.Uniform.misfit">[docs]</a>    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the misfit of a uniform distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>

<div class="viewcode-block" id="Uniform.gradient"><a class="viewcode-back" href="../../../api/distributions/Uniform.html#hmc_tomography.Distributions.Uniform.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method to compute the gradient of a uniform distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Uniform&quot;</span><span class="p">:</span>

        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">10</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">10</span>

        <span class="k">return</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompositeDistribution"><a class="viewcode-back" href="../../../api/distributions/CompositeDistribution.html#hmc_tomography.Distributions.CompositeDistribution">[docs]</a><span class="k">class</span> <span class="nc">CompositeDistribution</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Distribution distribution combined from multiple unconditional distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    dimensions : int</span>
<span class="sd">        Combined dimension of all the separate distributions</span>
<span class="sd">    list_of_distributions : List[_AbstractDistribution]</span>
<span class="sd">        List of all separate distributions.</span>


<span class="sd">    Raises</span>
<span class="sd">    ======</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raised if the passed dimensions do not correspond to the sum of the separate</span>
<span class="sd">        dimensions of each distribution.</span>


<span class="sd">    This class can be used when two or more sets of coordinates should be described by</span>
<span class="sd">    different distributions, e.g. when one set requires a Normal distribution and</span>
<span class="sd">    another a uniform distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">list_of_distributions</span><span class="p">:</span> <span class="n">_List</span><span class="p">[</span><span class="n">_AbstractDistribution</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;composite distribution&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">:</span> <span class="n">_List</span><span class="p">[</span>
            <span class="n">_AbstractDistribution</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">list_of_distributions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;This object describes how many dimensions each distribution has, ordered</span>
<span class="sd">        according to ``CompositeDistribution.separate_distributions``. Sums to</span>
<span class="sd">        ``CompositeDistribution.dimesions``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Assert that the passed distributions actually do represent the correct amount</span>
        <span class="c1"># of dimensions, and seperately extract the size of each distribution</span>
        <span class="n">computed_dimensions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="n">computed_dimensions</span> <span class="o">+=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">]</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">computed_dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions_cumulative</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span>
        <span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;This object describes each separate distribution index in combined model</span>
<span class="sd">        space. Invoking</span>
<span class="sd">        ``numpy.split(m, CompositeDistribution.enumerated_dimensions_cumulative)[:-1])``</span>
<span class="sd">        splits a vector appropriately for all separate distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">upper_bounds</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="c1"># Split coordinates for all sub-distributions ----------------------------------</span>
        <span class="n">split_coordinates</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions_cumulative</span>
        <span class="p">)</span>

        <span class="n">misfit</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Loop over distributions and add misfit ---------------------------------------</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="n">misfit</span> <span class="o">+=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">misfit</span><span class="p">(</span><span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">misfit</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Split coordinates for all sub-distributions ----------------------------------</span>
        <span class="n">split_coordinates</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions_cumulative</span>
        <span class="p">)</span>

        <span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over distributions and compute gradient ---------------------------------</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distribution</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">]))</span>

        <span class="c1"># Vertically stack gradients ---------------------------------------------------</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">gradient</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="n">gradient</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="CompositeDistribution.collapse_bounds"><a class="viewcode-back" href="../../../api/distributions/CompositeDistribution.html#hmc_tomography.Distributions.CompositeDistribution.collapse_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to restructure all composite bounds into top level object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="CompositeDistribution.corrector"><a class="viewcode-back" href="../../../api/distributions/CompositeDistribution.html#hmc_tomography.Distributions.CompositeDistribution.corrector">[docs]</a>    <span class="k">def</span> <span class="nf">corrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">momentum</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override method to correct an HMC particle for composite distribution, which</span>
<span class="sd">        is called after every time integration step. Calls all sub-correctors only if</span>
<span class="sd">        the object does not have bounds itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the coordinates :math:`\\mathbf{m}` upon which to operate by</span>
<span class="sd">            reference.</span>
<span class="sd">        momentum : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the momenta :math:`\\mathbf{p}` upon which to operate by</span>
<span class="sd">            reference.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with bounds of CompositeDistribution -----------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Lower bound correction</span>
            <span class="n">too_low</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Upper bound correction</span>
            <span class="n">too_high</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="c1"># If they are not set, check subdistributions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Split coordinates and momenta for all sub-distributions ------------------</span>
            <span class="n">split_coordinates</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions_cumulative</span>
            <span class="p">)</span>
            <span class="n">split_momenta</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">momentum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enumerated_dimensions_cumulative</span>
            <span class="p">)</span>

            <span class="c1"># And loop over separate distributions to check bounds</span>
            <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Lower bound correction</span>
                    <span class="n">too_low</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span>
                    <span class="p">)</span>
                    <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_low</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_low</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">split_momenta</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_low</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">if</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Upper bound correction</span>
                    <span class="n">too_high</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span>
                    <span class="p">)</span>
                    <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_high</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span>
                        <span class="o">-</span> <span class="n">split_coordinates</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_high</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">split_momenta</span><span class="p">[</span><span class="n">i_distribution</span><span class="p">][</span><span class="n">too_high</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CompositeDistribution&quot;</span><span class="p">:</span>

        <span class="c1"># Create a list of all possible distributions</span>
        <span class="n">available_distributions</span> <span class="o">=</span> <span class="n">_AbstractDistribution</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>

        <span class="c1"># We don&#39;t want to recursively create many distributions, so remove those</span>
        <span class="k">for</span> <span class="n">distribution_to_remove</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">CompositeDistribution</span><span class="p">,</span>
            <span class="n">AdditiveDistribution</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="n">available_distributions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">distribution_to_remove</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This guy only supports 2 dimensions</span>
            <span class="n">available_distributions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">Himmelblau</span><span class="p">)</span>

        <span class="c1"># We select distributions at random</span>
        <span class="n">selected_classes</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">available_distributions</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>

        <span class="n">list_of_instances</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_class</span><span class="o">.</span><span class="n">create_default</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_class</span> <span class="ow">in</span> <span class="n">selected_classes</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">CompositeDistribution</span><span class="p">(</span><span class="n">list_of_instances</span><span class="p">)</span></div>


<div class="viewcode-block" id="AdditiveDistribution"><a class="viewcode-back" href="../../../api/distributions/AdditiveDistribution.html#hmc_tomography.Distributions.AdditiveDistribution">[docs]</a><span class="k">class</span> <span class="nc">AdditiveDistribution</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Distribution generated by summing the characteristic functions of two other</span>
<span class="sd">    distributions.</span>

<span class="sd">    This is essentially the unnormalized Bayes&#39; rule.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">list_of_distributions</span><span class="p">:</span> <span class="n">_List</span><span class="p">[</span><span class="n">_AbstractDistribution</span><span class="p">],</span>
        <span class="n">lower_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper_bounds</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;additive distribution&quot;</span>

        <span class="c1"># Automatically get dimensionality  from first distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">list_of_distributions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">:</span> <span class="n">_List</span><span class="p">[</span>
            <span class="n">_AbstractDistribution</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">list_of_distributions</span>

        <span class="c1"># Assert that the passed distributions are of the right dimension</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">collapse_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">misfit</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Loop over distributions and add misfit ---------------------------------------</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="n">misfit</span> <span class="o">+=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">misfit</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">misfit</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Loop over distributions and compute gradient ---------------------------------</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>
            <span class="n">gradient</span> <span class="o">+=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">gradient</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="n">gradient</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="AdditiveDistribution.collapse_bounds"><a class="viewcode-back" href="../../../api/distributions/AdditiveDistribution.html#hmc_tomography.Distributions.AdditiveDistribution.collapse_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to restructure all composite bounds into top level object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over all subdistributions</span>
        <span class="k">for</span> <span class="n">i_distribution</span><span class="p">,</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="p">):</span>

            <span class="c1"># Assert that every subdistribution has the right shape</span>
            <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

            <span class="c1"># If the subdistribution has lower bounds ... act</span>
            <span class="k">if</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Assert the bounds have the right shape</span>
                <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If the top level distribution doesn&#39;t have lower bounds yet,</span>
                    <span class="c1"># simply add the new bounds</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the top level distribution does already have lower bounds, take</span>
                    <span class="c1">#  the maximum of every separate bound</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">distribution</span><span class="o">.</span><span class="n">lower_bounds</span>
                    <span class="p">)</span>

            <span class="c1"># If the subdistribution has upper bounds ... act</span>
            <span class="k">if</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Assert the bounds have the right shape</span>
                <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If the top level distribution doesn&#39;t have upper bounds yet,</span>
                    <span class="c1"># simply add the new bounds</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If the top level distribution does already have upper bounds, take</span>
                    <span class="c1"># the minimum of every separate bound</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">,</span> <span class="n">distribution</span><span class="o">.</span><span class="n">upper_bounds</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="AdditiveDistribution.add_distribution"><a class="viewcode-back" href="../../../api/distributions/AdditiveDistribution.html#hmc_tomography.Distributions.AdditiveDistribution.add_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">add_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span><span class="p">:</span> <span class="n">_AbstractDistribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a distribution to the object.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">separate_distributions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distribution</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">collapse_bounds</span><span class="p">()</span></div>

<div class="viewcode-block" id="AdditiveDistribution.corrector"><a class="viewcode-back" href="../../../api/distributions/AdditiveDistribution.html#hmc_tomography.Distributions.AdditiveDistribution.corrector">[docs]</a>    <span class="k">def</span> <span class="nf">corrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">momentum</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override method to correct an HMC particle for additive distribution, which is</span>
<span class="sd">        called after every time integration step. Calls all sub-correctors only if the</span>
<span class="sd">        object does not have bounds itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coordinates : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the coordinates :math:`\\mathbf{m}` upon which to operate by</span>
<span class="sd">            reference.</span>
<span class="sd">        momentum : numpy.ndarray</span>
<span class="sd">            Numpy array shaped as (dimensions, 1) representing a column vector</span>
<span class="sd">            containing the momenta :math:`\\mathbf{p}` upon which to operate by</span>
<span class="sd">            reference.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start with bounds of CompositeDistribution -----------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Lower bound correction</span>
            <span class="n">too_low</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_low</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Upper bound correction</span>
            <span class="n">too_high</span> <span class="o">=</span> <span class="n">coordinates</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span>
            <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">momentum</span><span class="p">[</span><span class="n">too_high</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span></div>

        <span class="c1"># # If they are not set, check subdistributions.</span>
        <span class="c1"># if self.lower_bounds is None and self.upper_bounds is None:</span>
        <span class="c1">#     # Split coordinates and momenta for all sub-distributions ----------------</span>
        <span class="c1">#     split_coordinates = _numpy.split(</span>
        <span class="c1">#         coordinates, self.enumerated_dimensions_cumulative</span>
        <span class="c1">#     )</span>
        <span class="c1">#     split_momenta = _numpy.split(</span>
        <span class="c1">#         momentum, self.enumerated_dimensions_cumulative</span>
        <span class="c1">#     )</span>

        <span class="c1">#     # And loop over separate distributions to check bounds</span>
        <span class="c1">#     for i_dis, distribution in enumerate(self.separate_distributions):</span>

        <span class="c1">#         if distribution.lower_bounds is not None:</span>
        <span class="c1">#             # Lower bound correction</span>
        <span class="c1">#             too_low = split_coordinates[i_dis] &lt; distribution.lower_bounds</span>
        <span class="c1">#             split_coordinates[i_dis][too_low] += 2 * (</span>
        <span class="c1">#                 distribution.lower_bounds[too_low]</span>
        <span class="c1">#                 - split_coordinates[i_dis][too_low]</span>
        <span class="c1">#             )</span>
        <span class="c1">#             split_momenta[i_dis][too_low] *= -1.0</span>
        <span class="c1">#         if distribution.upper_bounds is not None:</span>
        <span class="c1">#             # Upper bound correction</span>
        <span class="c1">#             too_high = split_coordinates[i_dis] &gt; distribution.upper_bounds</span>
        <span class="c1">#             split_coordinates[i_dis][too_high] += 2 * (</span>
        <span class="c1">#                 distribution.upper_bounds[too_high]</span>
        <span class="c1">#                 - split_coordinates[i_dis][too_high]</span>
        <span class="c1">#             )</span>
        <span class="c1">#             split_momenta[i_dis][too_high] *= -1.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AdditiveDistribution&quot;</span><span class="p">:</span>

        <span class="c1"># Create a list of all possible distributions</span>
        <span class="n">available_distributions</span> <span class="o">=</span> <span class="n">_AbstractDistribution</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>

        <span class="c1"># We don&#39;t want to recursively create many distributions, so remove those</span>
        <span class="k">for</span> <span class="n">distribution_to_remove</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="n">CompositeDistribution</span><span class="p">,</span>
            <span class="n">AdditiveDistribution</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="n">available_distributions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">distribution_to_remove</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This guy only supports 2 dimensions</span>
            <span class="n">available_distributions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">Himmelblau</span><span class="p">)</span>

        <span class="c1"># We select distributions at random</span>
        <span class="n">selected_classes</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">available_distributions</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">list_of_instances</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">d_class</span><span class="o">.</span><span class="n">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_class</span> <span class="ow">in</span> <span class="n">selected_classes</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">AdditiveDistribution</span><span class="p">(</span><span class="n">list_of_instances</span><span class="p">)</span></div>


<span class="c1"># This creates an alias for AdditiveDistribution</span>
<div class="viewcode-block" id="BayesRule"><a class="viewcode-back" href="../../../api/distributions/BayesRule.html#hmc_tomography.Distributions.BayesRule">[docs]</a><span class="k">class</span> <span class="nc">BayesRule</span><span class="p">(</span><span class="n">AdditiveDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to apply (the unnormalized) Bayes&#39; rule to two or more distributions.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="Himmelblau"><a class="viewcode-back" href="../../../api/distributions/Himmelblau.html#hmc_tomography.Distributions.Himmelblau">[docs]</a><span class="k">class</span> <span class="nc">Himmelblau</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Himmelblau&#39;s 2-dimensional function.</span>

<span class="sd">    Himmelblau&#39;s function is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x,y)=(x^{2}+y-11)^{2}+(x+y^{2}-7)^{2}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Himmelblau&#39;s function&quot;</span>
    <span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;Float representing the temperature (or annealing, :math:`T`) of Himmelblau&#39;s</span>
<span class="sd">    function.</span>

<span class="sd">    Alters the misfit function in the following way:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x,y)_T=\\frac{f(x,y)}{T}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>

<div class="viewcode-block" id="Himmelblau.misfit"><a class="viewcode-back" href="../../../api/distributions/Himmelblau.html#hmc_tomography.Distributions.Himmelblau.misfit">[docs]</a>    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the value of Himmelblau&#39;s function at the given coordinates.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span>
            <span class="p">((</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Himmelblau.gradient"><a class="viewcode-back" href="../../../api/distributions/Himmelblau.html#hmc_tomography.Distributions.Himmelblau.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a numpy.ndarray shaped as (dimensions, 1) containing the gradient of</span>
<span class="sd">        Himmelblau&#39;s function at the given coordinates.&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gradient</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">gradient</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">11</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gradient</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span></div>

    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Generating samples from this distribution is not implemented or supported.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Himmelblau&quot;</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_CustomExceptions</span><span class="o">.</span><span class="n">InvalidCaseError</span><span class="p">()</span>

        <span class="n">temperature</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">Himmelblau</span><span class="p">(</span><span class="n">temperature</span><span class="o">=</span><span class="n">temperature</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Mixture</span><span class="p">(</span><span class="n">_AbstractDistribution</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distributions</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span> <span class="o">=</span> <span class="n">distributions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">probabilities</span>

        <span class="k">for</span> <span class="n">dis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">dis</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
                <span class="n">dis</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

            <span class="k">assert</span> <span class="n">dis</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

    <span class="k">def</span> <span class="nf">misfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">misfits</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">misfit</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">misfit_bounds</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">_numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probabilities</span><span class="p">)</span> <span class="o">-</span> <span class="n">misfits</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>

        <span class="n">misfits</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">misfit</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span><span class="p">]</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distributions</span><span class="p">])</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probabilities</span><span class="p">)</span> <span class="o">-</span> <span class="n">misfits</span><span class="p">)</span>

        <span class="n">gr</span> <span class="o">=</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">prob</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">grad</span><span class="p">)</span> <span class="k">for</span> <span class="n">prob</span><span class="p">,</span> <span class="n">grad</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">gradients</span><span class="p">)]),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">gr</span> <span class="o">/</span> <span class="n">_numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Mixture&quot;</span><span class="p">:</span>

        <span class="n">Normal1</span> <span class="o">=</span> <span class="n">Normal</span><span class="o">.</span><span class="n">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="n">Normal2</span> <span class="o">=</span> <span class="n">Normal</span><span class="o">.</span><span class="n">create_default</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Mixture</span><span class="p">([</span><span class="n">Normal1</span><span class="p">,</span> <span class="n">Normal2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019-2020, Andrea Zunino, Andreas Fichtner, Lars Gebraad

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>